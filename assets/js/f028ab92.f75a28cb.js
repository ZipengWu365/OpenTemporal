"use strict";(globalThis.webpackChunkopentemporal_site=globalThis.webpackChunkopentemporal_site||[]).push([[6719],{6475:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"methods-concepts/symbolic-frequency","title":"Symbolic and Frequency-Based Methods (SAX, SFA, etc.)","description":"Tokenising and spectral approaches for noisy or irregular signals.","source":"@site/docs/methods-concepts/symbolic-frequency.md","sourceDirName":"methods-concepts","slug":"/methods-concepts/symbolic-frequency","permalink":"/OpenTemporal/docs/methods-concepts/symbolic-frequency","draft":false,"unlisted":false,"editUrl":"https://github.com/ZipengWu365/OpenTemporal/tree/main/docs/methods-concepts/symbolic-frequency.md","tags":[],"version":"current","frontMatter":{"title":"Symbolic and Frequency-Based Methods (SAX, SFA, etc.)","description":"Tokenising and spectral approaches for noisy or irregular signals."},"sidebar":"mainSidebar","previous":{"title":"Classical Representations (PAA, PLA, APCA)","permalink":"/OpenTemporal/docs/methods-concepts/classical-representations"},"next":{"title":"Decomposition, Trend, and Seasonality Methods (SSA, STL, etc.)","permalink":"/OpenTemporal/docs/methods-concepts/decomposition-trend"}}');var t=s(4848),o=s(8453);const r={title:"Symbolic and Frequency-Based Methods (SAX, SFA, etc.)",description:"Tokenising and spectral approaches for noisy or irregular signals."},a=void 0,c={},l=[{value:"Typical use cases",id:"typical-use-cases",level:2},{value:"Strengths",id:"strengths",level:2},{value:"Limitations",id:"limitations",level:2},{value:"When to consider them",id:"when-to-consider-them",level:2}];function d(e){const n={a:"a",h2:"h2",li:"li",p:"p",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"Symbolic Aggregate approXimation (SAX), Symbolic Fourier Approximation (SFA), wavelets, and related transforms recast time series into vocabularies or spectral coefficients."}),"\n",(0,t.jsx)(n.h2,{id:"typical-use-cases",children:"Typical use cases"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Large-scale motif discovery where hashing enables fast search."}),"\n",(0,t.jsx)(n.li,{children:"Mining anomaly candidates when raw values are dominated by noise."}),"\n",(0,t.jsx)(n.li,{children:"Bridging disparate sampling rates by comparing in the frequency domain."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"strengths",children:"Strengths"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Robust against small temporal shifts and amplitude noise."}),"\n",(0,t.jsx)(n.li,{children:"Facilitate discrete indexing structures and explainable rules."}),"\n",(0,t.jsx)(n.li,{children:"Work well with textual analytics tooling once series are tokenised."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"limitations",children:"Limitations"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Quantisation choices strongly influence performance."}),"\n",(0,t.jsx)(n.li,{children:"Spectral methods assume stationarity within windows."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"when-to-consider-them",children:"When to consider them"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"When analysts need interpretable motifs or symbolic rules."}),"\n",(0,t.jsx)(n.li,{children:"When storage/computation constraints prohibit raw-series retention."}),"\n",(0,t.jsx)(n.li,{children:"When comparing across devices with different sampling rates."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Combine symbolic encodings with decomposition methods (see ",(0,t.jsx)(n.a,{href:"/OpenTemporal/docs/methods-concepts/decomposition-trend",children:"Trend and Seasonality"}),") to isolate residual behaviour."]})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>a});var i=s(6540);const t={},o=i.createContext(t);function r(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);